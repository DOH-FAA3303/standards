{
  "hash": "7f8530bde83fcc38d43775f3a604d8d9",
  "result": {
    "markdown": "---\ntitle: \"Release Cycles\"\ndescription: Utilizing and automating Github Releases in your repo\ndate: September 1, 2023\ndate-modified: today\nauthor: \n  - name: Frank Aragona\n    email: frank.aragona@doh.wa.gov\n    affiliations:\n      - Washington Department of Health\n      - Data Integration/Quality Assurance\nformat: \n  html:\n    code-fold: false\n    code-overflow: wrap\n    toc: true\n    number-sections: true\nexecute: \n  freeze: true\n  echo: true\n  eval: false\nknitr: true\nfilters: \n  - line-highlight\n---\n\n\n::: note\n{{< fa file-circle-check size=\"3x\" >}} **Summary**\n\n1.  Github Releases take snapshots of you repo with each release\n2.  They can help devs and end users switch between repo versions\n3.  Change logs and semantic versioning can help document changes\n4.  Github Actions and pre-commit hooks can automate the release process\n:::\n\n<br>\n\n# Github Releases\n\nIn the right panel of your Github repo there is a section labeled Releases. Here you can create or find a version of your repo's code base. Each version comes with a changelog, tags, and downloadable source code. Developers and end-users may find this helpful to navigate to what the repo contained at specific release versions and have the source code available for download at the specific version.\n\n![](images/releases.PNG){.myframe}\n\n<br>\n\nIf you click on the releases you can see different release tags/versions. Each comes with a changelog, tag, git hash number, and zip files to download the repo *at the time the specific version was released*. This means you can automatically save repo snapshots and backups whenever your project cycle is released.\n\n![](images/releases_nav.gif){.myframe}\n\n<br>\n\nyou can flip through different releases and tags here\n\n![](images/releases_nav2.gif){.myframe}\n\n<br>\n\nYou can click on a tag and it will take you to the repo *at the time the specific version was released*\n\n![](images/releases_tags.gif){.myframe}\n\n# Semantic Versioning\n\nSoftware projects often label their releases using semantic versioning. It looks like this, where the software version numbers all have a definition:\n\n::: pic-border\n[![https://www.softwarecraftsperson.com/2020/12/06/semantic-versioning-semver-introduction/](images/semver.png)](https://www.softwarecraftsperson.com/2020/12/06/semantic-versioning-semver-introduction/)\n:::\n\n# Conventional Commits {#sec-cc}\n\nTo create the release cycle in your repo you may want to use Conventional Commits.\n\nConventional Commits are a way to format and standardize your commit messages, which can be used to then automate the repo's release cycle. For example, one conventional naming method is to label any commit associated with a new feature as `feat:` plus a commit message.\n\n-   The word `feat:` can trigger a Github Action to add that commit to your changelog under the **Features** header,\n-   and it will up-version the minor release version number.\n-   So if you are on release 1.0.0, a new `feat` will up-version the cycle to 1.1.0\n-   Commit titles that start with the word `fix:` as in a bug fix will up-version the patch number of the, i.e. 1.0.0 to 1.0.1\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://www.conventionalcommits.org/en/v1.0.0/\" title=\"Github Licenses\"></iframe>\n```\n\n# Automating The Release Cycle\n\nYou should consider automating your release cycle so that your project cycle is consistent and predictable. There are many different ways to approach this.\n\nSome repos have semi-automatic cycles where there is some manual component of releasing their software, whereas others are fully automated. Manual releases can work too for some scenarios.\n\n## Github Action for auto releases\n\nI recommend first creating a test repo for this. In the repo, create a Github Action workflow called `changelog.yml`. You can copy the full file below:\n\n::: myframe\n\n::: {.cell filename='.github/workflows/changelog.yml'}\n\n```{.yaml .cell-code}\nname: Changelog\non:\n  push:\n    branches:\n      - main\n\njobs:\n  changelog:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      # write permission is required to create a github release\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Conventional Changelog Action\n        id: changelog\n        uses: TriPSs/conventional-changelog-action@v3\n        with:\n          github-token: ${{ secrets.github_token }}\n          create-summary: true\n\n      - name: Create Release\n        uses: actions/create-release@v1\n        if: ${{ steps.changelog.outputs.skipped == 'false' }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.github_token }}\n        with:\n          prerelease: false\n          tag_name: ${{ steps.changelog.outputs.tag }}\n          release_name: ${{ steps.changelog.outputs.tag }}\n          body: ${{ steps.changelog.outputs.clean_changelog }}\n```\n:::\n\n:::\n\n\n# {.unnumbered}\n\nThis workflow will be triggered everytime a branch is merged to main. If that branch has [conventinal commit messages](@sec-cc) the commits will be summarized in the changelog. See an example workflow below:\n\n:::{.column-screen-inset-shaded layout-nrow=\"1\"}\n![](images/fix.PNG){.myframe}\n\n![](images/fix2.PNG){.myframe}\n:::\n\n<br>\n\nIf I make a branch off of main, I can add features, bug fixes, and more. If I used conventional commit messages in the title (i.e. `feat: message`, `fix: message`) the Github Action workflow will detect the trigger word in the title and divide the commit accordingly in the changelog. Notice how the commit title message gets output automatically into the changelog under the header **Bug Fixes** and the commit + commit hash number are generated. \n\nA new version will be released, and since this was just a bug fix the version number went from `v2.1.4` to `v2.1.5` since bug fixes only up-version the patch numbers\n\n\n<!--\n\n::: {.column-screen-inset-shaded layout-nrow=\"1\"}\nIf I make a branch off of main, I can add features, bug fixes, and more. If I used conventional commit messages in the title (i.e. `feat: message`, `fix: message`) the Github Action workflow will detect the trigger word in the title and divide the commit accordingly in the changelog. Notice how the commit title message gets output automatically into the changelog under the header **Bug Fixes** and the commit + commit hash number are generated. A new version will be released, and since this was just a bug fix the version number went from `v2.1.4` to `v2.1.5` since bug fixes only up-version the patch numbers\n\n![](images/fix.PNG){.myframe}\n\n![](images/fix2.PNG){.myframe}\n:::\n\n\n<br>\n\n\n::: {.column-screen-inset-shaded layout-nrow=\"1\"}\nIf you add multiple commit types to one branch and merge it to main the changelog will reflect all the commits (only for feat or fix) and _will up-version only one time._ If there one or more `feat` commits it will up-version the minor release. If there are no `feat` commits and only bug fixes it will only up-version the patch release number\n\n\n\n![](images/minor.PNG){.myframe}\n\nSee how the version number went from `v2.1.5` in the last release to `v2.2.0`. This happened because there is at least one `feat` commit in the new release. And since all of the other commits were included into on branch they are all included in this release cycle.\n:::\n\n-->\n\n# {.unnumbered} \n\nThe first step uses the Github Action `TriPSs/conventional-changelog-action@v3` which will scan your\n\n:::{.myframe}\n\n::: {.cell filename='.github/workflows/changelog.yml'}\n\n```{.yaml .cell-code}\nsteps:\n  - uses: actions/checkout@v2\n\n  - name: Conventional Changelog Action\n    id: changelog\n    uses: TriPSs/conventional-changelog-action@v3\n    with:\n      github-token: ${{ secrets.github_token }}\n      create-summary: true\n```\n:::\n\n:::\n\nThe second step uses the Github Action `actions/create-release@v1` which will create git tags with the version number and a changelog with downloadable source code\n\n:::{.myframe}\n\n::: {.cell filename='.github/workflows/changelog.yml'}\n\n```{.yaml .cell-code}\n- name: Create Release\n  uses: actions/create-release@v1\n  if: ${{ steps.changelog.outputs.skipped == 'false' }}\n  env:\n    GITHUB_TOKEN: ${{ secrets.github_token }}\n  with:\n    prerelease: false\n    tag_name: ${{ steps.changelog.outputs.tag }}\n    release_name: ${{ steps.changelog.outputs.tag }}\n    body: ${{ steps.changelog.outputs.clean_changelog }}\n```\n:::\n\n\n:::\n\n\n\n# Resources\n\nThese videos are excellent summaries of how to use Github Releases and semantic versioning\n\n\n{{< video https://www.youtube.com/embed/fcHJZ4pMzBs?si=jb-1lgaYevGqOUU9 >}}\n\n\n{{< video https://www.youtube.com/embed/q3qE2nJRuYM?si=7nQ7itJFt3oUtgaL >}}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}