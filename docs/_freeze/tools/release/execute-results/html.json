{
  "hash": "ea34db6947dcbc5fee3a0adfcb3762aa",
  "result": {
    "markdown": "---\ntitle: \"Release Cycles\"\ndescription: Utilizing and automating Github Releases in your repo\ndate: September 1, 2023\ndate-modified: today\nauthor: \n  - name: Frank Aragona\n    email: frank.aragona@doh.wa.gov\n    affiliations:\n      - Washington Department of Health\n      - Data Integration/Quality Assurance\nformat: \n  html:\n    code-fold: false\n    code-overflow: wrap\n    toc: true\n    number-sections: true\nexecute: \n  freeze: true\n  echo: true\n  eval: false\nknitr: true\nfilters: \n  - line-highlight\n---\n\n\n::: obj\n**Summary**\n\n1.  Github Releases take snapshots of you repo with each release\n2.  They can help devs and end users switch between repo versions\n3.  Change logs and semantic versioning can help document changes\n4.  Github Actions and pre-commit hooks can automate the release process\n:::\n\n<br>\n\n# Semantic Versioning\n\nGithub Releases are a great way to keep your development process organized. Software projects often use releases with semantic versioning where the version numbers serve as snapshots of the project, and each release contains the version number and a changelog summarizing all the changes that took place.\n\nSemantic Versioning looks like this, where the software version numbers all have a definition:\n\n::: pic-border\n[![https://www.softwarecraftsperson.com/2020/12/06/semantic-versioning-semver-introduction/](images/semver.png)](https://www.softwarecraftsperson.com/2020/12/06/semantic-versioning-semver-introduction/)\n:::\n\n# Github Releases\n\nIn the right panel of your Github repo there is a section labeled Releases. Here you can find each release with a change log attached.\n\n![](images/releases.PNG){.myframe}\n\n<br>\n\nIf you click on the releases you can see different release tags/versions. Each comes with a changelog, git hash number, and zip files to download the repo *at the time the specific version was released*. This means you can automatically save repo snapshots and backups whenever your project cycle is released.\n\n![](images/releases_nav.gif){.myframe}\n\n<br>\n\nyou can flip through different releases and tags here\n\n![](images/releases_nav2.gif){.myframe}\n\n<br>\n\nYou can click on a tag and it will take you to the repo *at the time the specific version was released*\n\n![](images/releases_tags.gif){.myframe}\n\n# Conventional Commits\n\nTo create the release cycle in your repo you may want to use Conventional Commits.\n\nConventional Commits are a way to format and standardize your commit messages, which can be used to then automate the repo's release cycle. For example, one conventional naming method is to label any commit associated with a new feature as `feat:` plus a commit message.\n\n-   The word `feat:` can trigger a Github Action to add that commit to your changelog under the **Features** header,\n-   and it will up-version the minor release version number.\n-   So if you are on release 1.0.0, a new `feat` will up-version the cycle to 1.1.0\n-   Commit titles that start with the word `fix:` as in a bug fix will up-version the patch number of the, i.e. 1.0.0 to 1.0.1\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://www.conventionalcommits.org/en/v1.0.0/\" title=\"Github Licenses\"></iframe>\n```\n\n\n# Automating The Release Cycle\n\n# Resources\n\nThese videos are excellent summaries of how to use Github Releases and semantic versioning\n\n\n{{< video https://www.youtube.com/embed/fcHJZ4pMzBs?si=jb-1lgaYevGqOUU9 >}}\n\n\n{{< video https://www.youtube.com/embed/q3qE2nJRuYM?si=7nQ7itJFt3oUtgaL >}}\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}